<?xml version="1.0" encoding="utf-8"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.1.6">Jekyll</generator><link href="http://bblu.github.io/feed.xml" rel="self" type="application/atom+xml" /><link href="http://bblu.github.io/" rel="alternate" type="text/html" /><updated>2018-03-12T01:40:14+08:00</updated><id>http://bblu.github.io/</id><title>bblu&#39;s blog</title><subtitle>Just do IT</subtitle><author><name>bblu</name><email>gmwblu@gmail.com</email></author><entry><title>ios开发timepi第3天-添加UIPickerView</title><link href="http://bblu.github.io/2018-03-11-swift-timepi-3rd.html" rel="alternate" type="text/html" title="ios开发timepi第3天-添加UIPickerView" /><published>2018-03-11T00:00:00+08:00</published><updated>2018-03-11T00:00:00+08:00</updated><id>http://bblu.github.io/swift-timepi-3rd</id><content type="html" xml:base="http://bblu.github.io/2018-03-11-swift-timepi-3rd.html">&lt;blockquote&gt;
  &lt;p&gt;解析json初始化pickerview选择todo事项，一开始想把Picker的Datasource和Delegate独立出去，互相操作起来太复杂先放弃了以后再说吧。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;section&quot;&gt;常用的操作&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;重构： Command + clike 可以调出选项转到定义&lt;/li&gt;
  &lt;li&gt;查找： Command + F&lt;/li&gt;
  &lt;li&gt;替换： Command + Option+F&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;uipickerview&quot;&gt;UIPickerView更新选项和设置默认项&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    public func pickerView&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;select0 &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; picker.selectedRow&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;inComponent: 0&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        var index &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; select0 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 100 + component &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; row
        &lt;span class=&quot;k&quot;&gt;if&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;component&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;==&lt;/span&gt;0&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
            picker.reloadComponent&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; //重新加载二级选项
            picker.selectRow&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;1, inComponent: 1, animated: &lt;span class=&quot;nb&quot;&gt;true&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; //二级选项里默认的索引是1
            index +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
        print&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;pickerView.delegate.didSelectRow[select0=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;select0),com=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;component),row=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;row)],index=&lt;/span&gt;&lt;span class=&quot;se&quot;&gt;\(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;index)&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        curLabel.text &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;current is &quot;&lt;/span&gt; + getLabel&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;index:index&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;../assets/in-post/2018-03-11-swift-timepie-picker.png&quot; alt=&quot;add source file to project&quot; /&gt;&lt;/p&gt;</content><author><name>bblu</name><email>gmwblu@gmail.com</email></author><category term="ios" /><category term="swift" /><summary>解析json初始化pickerview选择todo事项，一开始想把Picker的Datasource和Delegate独立出去，互相操作起来太复杂先放弃了以后再说吧。</summary></entry><entry><title>ios开发timepi第2天-解析json添加按钮</title><link href="http://bblu.github.io/2018-03-09-swift-timepi-2nd.html" rel="alternate" type="text/html" title="ios开发timepi第2天-解析json添加按钮" /><published>2018-03-09T00:00:00+08:00</published><updated>2018-03-09T00:00:00+08:00</updated><id>http://bblu.github.io/swift-timepi-2nd</id><content type="html" xml:base="http://bblu.github.io/2018-03-09-swift-timepi-2nd.html">&lt;blockquote&gt;
  &lt;p&gt;被锤子打击之后就没怎么去写日程了，除了失望另一个很重要的原因是直接在Google日历上无论是添加计划还是修改计划都太麻烦，为自己又不是能完全按照时间计划去执行的人，也没有那么多时间去搞了。那就换手机了，在苹果应用市场上搜集了十几款时间日程管理的软件发现都不是我想要的，于是就想自己开发一个这就是我开发这个软件的原因。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;最早起名叫Myday感觉太土了这次重新做改名叫TimePie，github单独起了一个【&lt;a href=&quot;https://github.com/bblu/timepie&quot;&gt;TimePie&lt;/a&gt;】。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;各种白痴问题&lt;/h2&gt;
&lt;p&gt;### 1.添加按钮事件
这个以前都是有鼠标的，这次出差没带鼠标单击了半天就是不能把按钮关联到事件创建上，一晚上也无解直到第二天才恍然大悟应该是右击。&lt;/p&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.添加资源文件&lt;/h3&gt;
&lt;p&gt;资源文件的结构要和解码的结构对应
&lt;code class=&quot;highlighter-rouge&quot;&gt;base
{
    &quot;user&quot;:&quot;bblu&quot;,
    &quot;date&quot;:&quot;2018-03-09&quot;,
    &quot;items&quot;:[
             {&quot;name&quot;: &quot;work&quot;,&quot;alias&quot;:&quot;工作&quot;,&quot;icon&quot;:&quot;📌&quot;,&quot;code&quot;:0,&quot;span&quot;:360},
             {&quot;name&quot;: &quot;coding&quot;,&quot;alias&quot;:&quot;编码&quot;,&quot;icon&quot;:&quot;👨🏻‍💻&quot;,&quot;code&quot;:1,&quot;span&quot;:60}
    ]
}
&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;写好json的配置文件放到对应目录下,找的代码这么也读不出来，反复看视频和查资料发现是自己白痴了！
解决方法：打开build Phases中的 copy Bundle Resources点击下面的+把你需求的文件添加进去，然后再运行就可以获取到你的文件路径了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/in-post/2018-03-09-swift-json-file.png&quot; alt=&quot;add source file to project&quot; /&gt;&lt;/p&gt;

&lt;h3 id=&quot;swift-4codable&quot;&gt;3.swift 4新增的codable方式定义自己的数据模式&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;struct TodoConfig:Decodable&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;user:String
    &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;date:String
    &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;items:[TodoItem]
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

struct TodoItem: Decodable&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;name:String
    &lt;span class=&quot;nb&quot;&gt;let alias&lt;/span&gt;:String
    &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;icon:String
    &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;code:Int
    var span:Int
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;### 4.通过代码初始化按钮&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;    func addButtons&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;items:[TodoItem]&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;item &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;items&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;pos &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; item.code
            //pos:   0,  1,  2,  3,  4
            //     100,101,102,103,104
            &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;px &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pos % 10&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 80
            &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;py &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 400 + &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;pos / 10&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 50
            &lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;btnItem &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; UIButton&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;frame: CGRect&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x:px, y: py, width: 80, height: 30&lt;span class=&quot;o&quot;&gt;))&lt;/span&gt;
            //btnItem.addTarget&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;self, action: Selector&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clickItem&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;: UIControlEvents.touchUpInside&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            btnItem.translatesAutoresizingMaskIntoConstraints &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;nb&quot;&gt;false
            &lt;/span&gt;btnItem.setTitle&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;item.alias, &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;: UIControlState.normal&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            btnItem.setTitleColor&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;UIColor.blue, &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;: UIControlState.normal&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            //btnItem.backgroundColor &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; UIColor.lightGray
            // btnItem.addTarget&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;self, action: Selector&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;clickItem&quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;, 
            &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;: UIControlEvents.touchUpInside&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
            self.view.addSubview&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;btnItem&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;&lt;img src=&quot;../assets/in-post/2018-03-09-swift-timepie-btn.png&quot; alt=&quot;add source file to project&quot; /&gt;&lt;/p&gt;</content><author><name>bblu</name><email>gmwblu@gmail.com</email></author><category term="ios" /><category term="swift" /><summary>被锤子打击之后就没怎么去写日程了，除了失望另一个很重要的原因是直接在Google日历上无论是添加计划还是修改计划都太麻烦，为自己又不是能完全按照时间计划去执行的人，也没有那么多时间去搞了。那就换手机了，在苹果应用市场上搜集了十几款时间日程管理的软件发现都不是我想要的，于是就想自己开发一个这就是我开发这个软件的原因。</summary></entry><entry><title>ios开发timepi第1天-知识准备和设计</title><link href="http://bblu.github.io/2018-03-09-swift-timepi-1st.html" rel="alternate" type="text/html" title="ios开发timepi第1天-知识准备和设计" /><published>2018-03-09T00:00:00+08:00</published><updated>2018-03-09T00:00:00+08:00</updated><id>http://bblu.github.io/swift-timepi-1st</id><content type="html" xml:base="http://bblu.github.io/2018-03-09-swift-timepi-1st.html">&lt;blockquote&gt;
  &lt;p&gt;很早一直用google日历来计划日程,google日历的好处是方便导出可以自己分析时间的支配情况，比如运动、读书、平均睡眠时间等，锤子手机的日历使用起来比谷歌方便一些，还可以自动同步到谷歌于是就在锤子手机上记录了两年时间，我是每年会导出备份一下，备份第二年的时候发现有近十个月等日程没有同步上谷歌。锤子日历显示的日程都有也没有提示说同步失败，然后就把耐心消磨殆尽和客服反应这个问题，前后搞了大约有一个多月的时间，最后在客服的努力下一条日程都不剩了，还有个什么时间胶囊什么欢喜云显然都是摆设很显然我就是那个倒霉蛋，后来我想了一下别人没有这个问题并不一定是他们运气有多好而是他们根本不用日程或者不用锤子手机，这么说来不用锤子手机可能也是一种运气。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;被锤子打击之后就没怎么去写日程了，除了失望另一个很重要的原因是直接在Google日历上无论是添加计划还是修改计划都太麻烦，为自己又不是能完全按照时间计划去执行的人，也没有那么多时间去搞了。那就换手机了，在苹果应用市场上搜集了十几款时间日程管理的软件发现都不是我想要的，于是就想自己开发一个这就是我开发这个软件的原因，最早起名叫Myday感觉太土了这次重新做改名叫TimePie，github单独起了一个【&lt;a href=&quot;https://github.com/bblu/timepie&quot;&gt;TimePie&lt;/a&gt;】。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;知识准备&lt;/h2&gt;
&lt;p&gt;一个新的领域最好的入门办法不是系统的看书而是找一个视频的helloWord看一遍，然后遇到什么问题针对性的去找解决方案。
油管上有许多推荐 Michel Deiman 的【&lt;a href=&quot;https://www.youtube.com/watch?v=71pyOB4TPRE&amp;amp;list=PLPA-ayBrweUzGFmkT_W65z64MoGnKRZMq&quot;&gt;Stanford CS193P iOS 11 Swift 4&lt;/a&gt;】把前面一两集看完基本就差不多可以开干了。国内公开课应该也能搜得到，英语不过关的就重点看看xcode操作，打开字幕反而会分散注意力效果反而不好。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;第一天是列个提纲画个概要界面布局&lt;/h2&gt;
&lt;blockquote&gt;
  &lt;p&gt;时间分配记录和计划软件，饼状图好像要自定义控件，我现在连xcode里边的picerview都搞不懂，先用一个标签代替,先记录在分析然后完善。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;目标：用最少的操作记录每天时间的分配。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-2&quot;&gt;时间管理分两级大类下面有小分类&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;工作0 [编码1，文档2，会议3，出差4]&lt;/li&gt;
  &lt;li&gt;学习1 [技术1，读书2，总结3，开发4]&lt;/li&gt;
  &lt;li&gt;家庭2 [子女1，配偶2，家务3，家居4]&lt;/li&gt;
  &lt;li&gt;运动3 [骑行1，跑步2，力量3，轮滑4]&lt;/li&gt;
  &lt;li&gt;出行4 [步行1，汽车2，铁路3，飞船4]&lt;/li&gt;
  &lt;li&gt;个人5 [睡觉1，洗漱2，吃饭3，发呆4]&lt;/li&gt;
  &lt;li&gt;休闲6 [购物1，影音2，资讯3，出游4]&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;requirements--functions&quot;&gt;Requirements &amp;amp; Functions&lt;/h3&gt;
&lt;ul&gt;
  &lt;li&gt;
    &lt;p&gt;TimePie可以指定Plan去todo分配时间，也可以单纯记录每日的时间在不同方面的花销。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;可以通过增加循环日程按钮添加计划事件todo，todo可以autoStop，也可以autoContinue。&lt;/p&gt;
  &lt;/li&gt;
  &lt;li&gt;
    &lt;p&gt;指定每日Plan的时候可以把重要的计划设定为todo，设定为todo的plan会进行审核，审核的方式有两种，第一种较为宽松只要当天完成了规定时长的plan就算完成，比如每天跑步30分钟。第二种比较严格需要在plan的时间段完成才算完成。&lt;/p&gt;
  &lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;section-3&quot;&gt;学习笔记&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;standford ios Lecture @ 19:30
// 变量占位符‘_’ 忽略参数或变量
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;_ &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0...CardNum&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
...
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;_ &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;0..&amp;lt;CardNum&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;&lt;span class=&quot;nv&quot;&gt;a&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;Card
cardList.append&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;a&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

// optional var 
var myditc &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; Dictionary&amp;lt;Int,String&amp;gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;
// 定义一个严格类型的字典
var myditc &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;Int:String]&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt;

// ?? 如果Optional var 不为nil返回，否则返回？？后面的值
func getEmoji&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;card:Card&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; -&amp;gt; String&lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;somthing ?? otherchoise
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

// lazy property

// countablerRange setp by floating point like 0.3
// how to &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;that like  &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;nv&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.5; i&amp;lt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 15.25; i +&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;0.3&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;?
&lt;span class=&quot;k&quot;&gt;for &lt;/span&gt;i &lt;span class=&quot;k&quot;&gt;in &lt;/span&gt;stride&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;from:0.5, through:15.25, by:0.3&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;
...
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
// Tuples is nothing more than a group of values
&lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;x:&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;String,Int,Double&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;, 5, 0.87&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;world, number, value&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; x
print&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;world&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; // hello
&lt;span class=&quot;nb&quot;&gt;let &lt;/span&gt;x: &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;w:String, i:Int, v:Double&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;hello&quot;&lt;/span&gt;, 5, 0.87&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
print&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;x.w&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; // hello

// rename tupes elements on access
&lt;span class=&quot;nb&quot;&gt;let&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;wrd, num, val&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; x

// computed properties[ getter or setter like c#]
// var foo: Double
var foo:Double &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
get &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
// &lt;span class=&quot;k&quot;&gt;return &lt;/span&gt;the calculated value of foo
// 
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;nb&quot;&gt;set&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;newValue&lt;span class=&quot;o&quot;&gt;){&lt;/span&gt;   //without &lt;span class=&quot;nb&quot;&gt;set &lt;/span&gt;it is &lt;span class=&quot;s1&quot;&gt;&#39;read only&#39;&lt;/span&gt;
// &lt;span class=&quot;k&quot;&gt;do &lt;/span&gt;something based on the fact that foo has changed to newValue
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>bblu</name><email>gmwblu@gmail.com</email></author><category term="ios" /><category term="swift" /><summary>很早一直用google日历来计划日程,google日历的好处是方便导出可以自己分析时间的支配情况，比如运动、读书、平均睡眠时间等，锤子手机的日历使用起来比谷歌方便一些，还可以自动同步到谷歌于是就在锤子手机上记录了两年时间，我是每年会导出备份一下，备份第二年的时候发现有近十个月等日程没有同步上谷歌。锤子日历显示的日程都有也没有提示说同步失败，然后就把耐心消磨殆尽和客服反应这个问题，前后搞了大约有一个多月的时间，最后在客服的努力下一条日程都不剩了，还有个什么时间胶囊什么欢喜云显然都是摆设很显然我就是那个倒霉蛋，后来我想了一下别人没有这个问题并不一定是他们运气有多好而是他们根本不用日程或者不用锤子手机，这么说来不用锤子手机可能也是一种运气。</summary></entry><entry><title>自动化和敏捷成就了CI和CD</title><link href="http://bblu.github.io/2018-03-03-devops-ci-cd.html" rel="alternate" type="text/html" title="自动化和敏捷成就了CI和CD" /><published>2018-03-03T00:00:00+08:00</published><updated>2018-03-03T00:00:00+08:00</updated><id>http://bblu.github.io/devops-ci-cd</id><content type="html" xml:base="http://bblu.github.io/2018-03-03-devops-ci-cd.html">&lt;blockquote&gt;
  &lt;p&gt;关于敏捷开发自动化测试运维等随笔&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;相对于传统的开发模型，集成部署是两大块内容，以前做不到持续是有历史原因的因为项目的迭代的周期太长，集成一次光集成测试这一项就会大动干戈资源协调人力分配短时间搞不定。&lt;/p&gt;

&lt;p&gt;随着集成和部署的工作的颗粒度不断细化和专业化，脚本工具自动化程度越来越高，伴随这敏捷的东风，CI和CD迎来了devops的春天。这个过程极像CPU指令集架构从CSIC到RISC的演变过程。事情越简单越可以利用cpu的高频率解决问题，结果反而因为易用性好、通用性强、模式统一，方便部署等优点取得最终胜利。问题处理的越轻量级执行的越快，谁不想轻快的工作呢？&lt;/p&gt;</content><author><name>bblu</name><email>gmwblu@gmail.com</email></author><category term="devops" /><category term="ci" /><category term="cd" /><summary>关于敏捷开发自动化测试运维等随笔</summary></entry><entry><title>Python/uWSGI快速入门</title><link href="http://bblu.github.io/2018-02-26-quick-start-uwsgi.html" rel="alternate" type="text/html" title="Python/uWSGI快速入门" /><published>2018-02-26T00:00:00+08:00</published><updated>2018-02-26T00:00:00+08:00</updated><id>http://bblu.github.io/quick-start-uwsgi</id><content type="html" xml:base="http://bblu.github.io/2018-02-26-quick-start-uwsgi.html">&lt;p&gt;uWSGI是一个Web服务器，它实现了WSGI协议(Web Server Gateway Interface)、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。&lt;/p&gt;

&lt;p&gt;&lt;em&gt;** 要注意 WSGI / uwsgi / uWSGI 这三个概念的区分 **&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;WSGI是一种编程接口,它适用于 Python 语言,定义了 web服务器和 web应用之间的接口规范。当前运行在WSGI协议之上的web框架有Bottle, Flask, Django。&lt;/li&gt;
  &lt;li&gt;uwsgi是一种传输协议，在此常用于在uWSGI服务器与其他网络服务器的数据通信,是uWSGI服务器的独占协议，用于定义传输信息的类型(type of information)，每一个uwsgi packet前4byte为传输信息类型的描述，与WSGI协议是两种东西，据说该协议是fcgi协议的10倍快。。&lt;/li&gt;
  &lt;li&gt;uWSGI是一个web服务器，实现了WSGI协议、uwsgi协议、http协议等。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;【&lt;a href=&quot;https://www.zhihu.com/question/46945479/answer/104066078&quot;&gt;知乎-灵剑&lt;/a&gt;】:
WSGI是一种编程接口，而uwsgi是一种传输协议，从作用上来讲，的确跟fastcgi是最接近的。跟fastcgi的区别在于它是面向多并发的。我们知道fastcgi是CGI的替代品，它的工作方式仍然跟CGI是类似的，当一个请求进入的时候，通过socket发送请求的环境变量，然后发送POST数据（相当于CGI的stdin），然后等待程序输出（相当于CGI的stdout），等输出结束后，再发送下一个请求。这就导致fastcgi最大的并发量被限制为fastcgi后端的数量，显然这样的服务器模式对于并发量很大、单个请求耗时比较长的服务是不合适的，因此很多时候我们不愿意使用fastcgi部属而是使用反向代理的方式配置。但是跟反向代理比起来，fastcgi显然也是有好处的，最重要的好处在于解析HTTP协议的部分被offload到了前端服务器一级，后端服务器不再解析HTTP协议，这样就减轻了后端的压力，由于前端是nginx这样用C/C++高性能实现的服务器，比起在后端的Python当中使用脚本语言解析HTTP协议，效率要高不少。uwsgi想要继承fastcgi的这种好处，它通过将消息分片的方式，可以在一个socket上并发传输多个请求，这样就解决了一个连接上一次只能传输一个请求的问题。熟悉HTTP2.0的话会发现这个分片机制跟HTTP2.0很像。&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;uWSGI 是一个(巨大的) C 应用，所以你需要一个 C 编译器(比如 gcc 或者 clang)和 Python 开发版头文件。
在 Debian 系的发行版上一条命令就够了。&lt;/p&gt;

&lt;p&gt;apt-get install build-essential python-dev&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;你有多种方式来安装 uWSGI 的 Python 包：&lt;/p&gt;
&lt;/blockquote&gt;

&lt;ul&gt;
  &lt;li&gt;使用 pip :pip install uwsgi&lt;/li&gt;
  &lt;li&gt;网络安装 :curl http://uwsgi.it/install | bash -s default /tmp/uwsgi
(这将会把 uWSGI 二进制文件安装到 /tmp/uwsgi 下，你可以随意修改它)。&lt;/li&gt;
  &lt;li&gt;源代码然后 make 安装&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;wget http://projects.unbit.it/downloads/uwsgi-latest.tar.gz
tar zxvf uwsgi-latest.tar.gz
cd &lt;dir&gt;
make
(make 完后你会在你的当前目录下得到一个 uwsig 的二进制文件)。&lt;/dir&gt;&lt;/p&gt;

&lt;p&gt;通过你的发行版的包管理器安装是不能面面俱到的(不可能让所有人都开心)，但是一般的规则都适用。
当你使用发行版提供的包来测试这个快速入门的时候，一件你可能想重视的事情就是很有可能 你的发行版是用模块化的方式构建的(每个特性都是一个不同的必须被加载的插件)。 为了完成这个快速入门，你必须在前面第一个例子的前面加上 –plugin python,http 选项， 以及当 HTTP 路由被移除时加上 –plugin python 选项(这可能对你没什么用，继续阅读就好)。&lt;/p&gt;

&lt;h2 id=&quot;wsgi-&quot;&gt;第一个 WSGI 应用&lt;/h2&gt;
&lt;p&gt;让我们从一个简单的 “Hello World” 例子开始吧(这是在 Python 2.x 中，Python 3.x 需要 返回字节字符串，看下面)：&lt;/p&gt;

&lt;h3 id=&quot;python-2x-&quot;&gt;Python 2.x 版本如下&lt;/h3&gt;
&lt;p&gt;def application(env, start_response):
    start_response(‘200 OK’, [(‘Content-Type’,’text/html’)])
    return [“Hello World”]&lt;/p&gt;

&lt;p&gt;(保存为 foobar.py)。&lt;/p&gt;

&lt;p&gt;正如你看到的，它由一个单独的 Python 函数组成。它的名字是 “application”，这是 默认的函数名，uWSGI 的 Python 加载器将会搜索这个名字(但你当然可以修改它)。&lt;/p&gt;

&lt;h3 id=&quot;python-3x-&quot;&gt;Python 3.x 版本如下&lt;/h3&gt;
&lt;p&gt;def application(env, start_response):
    start_response(‘200 OK’, [(‘Content-Type’,’text/html’)])
    return [b”Hello World”]&lt;/p&gt;

&lt;p&gt;把它部署到 HTTP 端口 9090&lt;/p&gt;

&lt;p&gt;现在运行 uWSGI 来启动一个会把请求传递给你的 WSGI 应用的 HTTP 服务器/路由器。&lt;/p&gt;

&lt;p&gt;uwsgi –http :9090 –wsgi-file foobar.py&lt;/p&gt;

&lt;p&gt;这就是全部了。
&amp;gt; 注解
当你有前端 web 服务器时不要使用 –http 选项，使用 –http-socket。继续阅读快速入门来理解为什么要这么做。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;添加并发和监控&lt;/h2&gt;
&lt;p&gt;你想做的第一件事可能就是增加并发(uWSGI 默认启动一个单独的进程和一个单独的线程)。
你可以通过 –processes 选项或者 –threads (或者两个选项都使用)来增加更多的进程或者线程。&lt;/p&gt;

&lt;p&gt;uwsgi –http :9090 –wsgi-file foobar.py –master –processes 4 –threads 2&lt;/p&gt;

&lt;p&gt;这将会产生 4 个进程(每个进程 2 个线程)，一个主进程(当你的进程死掉时会重新 spawn 一个新的)以及 HTTP 路由器(见前面)。
一个重要的任何就是监控。知道发生了什么在生产环境中是极其重要的。&lt;/p&gt;

&lt;p&gt;stats 子系统允许你 用 JSON 输出 uWSGI 的内部数据：
uwsgi –http :9090 –wsgi-file foobar.py –master –processes 4 –threads 2 –stats 127.0.0.1:9191&lt;/p&gt;

&lt;p&gt;向你的应用发送几个请求然后 telnet 到 9191 端口，你将得到大量有趣的信息。你可能想要使用 “uwsgitop” (使用 pip install 你就能得到它)，这是一个类似 top 的工具，用于监控应用实例。
&amp;gt; 注意
将 stats 套接字(socket)绑定到私有地址(除非你知道你在做什么)，否则任何人都可以访问到它！&lt;/p&gt;

&lt;h2 id=&quot;web-&quot;&gt;放到一个完整的 web 服务器后&lt;/h2&gt;
&lt;p&gt;即使 uWSGI HTTP 路由器(router)是一个可靠的高性能服务器，你可能还是想把你的应用放到一完整的 web 服务器后。&lt;/p&gt;

&lt;p&gt;uWSGI 通常和 HTTP，FastCGI，SCGI 以及它自己特有的协议 “uwsgi” (呃，名字不应该这么取的) 通信。&lt;/p&gt;

&lt;p&gt;性能最高的协议显然是 uwsgi，并且早已被 nginx 和 Cherokee 支持 (同时 Apache 也有许多可用的模块)。&lt;/p&gt;

&lt;p&gt;一个普通的 nginx 配置如下：&lt;/p&gt;

&lt;p&gt;location / {
    include uwsgi_params;
    uwsgi_pass 127.0.0.1:3031;
}&lt;/p&gt;

&lt;p&gt;这个意思是说 “把每个请求传递到服务器绑定的端口 3031，并且使用 uwsgi 协议通信”。&lt;/p&gt;

&lt;p&gt;现在我们可以 spawn 一个 uWSGI 进程来天然地以 uwsgi 协议通信：
uwsgi –socket 127.0.0.1:3031 –wsgi-file foobar.py –master –processes 4 –threads 2 –stats 127.0.0.1:9191&lt;/p&gt;

&lt;p&gt;如果你运行 ps aux ，你将会看到少了一个进程。HTTP 路由器(router)已经从我们的 “workers” (分配给 uWSGI 的进程) 中被移除了，这些 worker 便是天然地用来以 uwsgi 协议形式通信的。&lt;/p&gt;

&lt;p&gt;如果你的代理/web 服务器/路由器使用 HTTP 协议，你必须告诉 uWSGI 使用 HTTP 协议(这与通过 –http spawn 一个它自己的代理是不一样的)：&lt;/p&gt;

&lt;p&gt;uwsgi –http-socket 127.0.0.1:3031 –wsgi-file foobar.py –master –processes 4 –threads 2 –stats 127.0.0.1:9191&lt;/p&gt;

&lt;h2 id=&quot;uwsgi&quot;&gt;开机自启动 uWSGI&lt;/h2&gt;
&lt;p&gt;如果你打算打开 vi 写一个 init.d 脚本来启动 uWSGI，坐下来冷静一下然后先确保 你的系统没有提供一个更好(更现代化)的方式。
没一个发行版会选择一个启动系统 (Upstart, Systemd…)，除此之外也有许多 进程管理工具(supervisord, god, monit, circus…)。
uWSGI 与上面列出的那些工具都集成得很好(我们希望如此)，但是如果你想部署大量应用的话， 看看 uWSGI 的 Emperor - 它或多或少是每个开发运维工程师的梦想。&lt;/p&gt;

&lt;h2 id=&quot;django&quot;&gt;部署 Django&lt;/h2&gt;
&lt;p&gt;Django 可能是使用得最多的 Python web 框架了。部署它非常简单(我们仍然使用 4 个进程，2 个线程的配置)。&lt;/p&gt;

&lt;p&gt;假定你的 Django 项目在 /home/foobar/myproject 下：&lt;/p&gt;

&lt;p&gt;uwsgi –socket 127.0.0.1:3031 –chdir /home/foobar/myproject/ –wsgi-file myproject/wsgi.py –master –processes 4 –threads 2 –stats 127.0.0.1:9191&lt;/p&gt;

&lt;p&gt;(通过 –chdir 选项我们可以移动一个特定的目录)。在 Django 中为了正确的加载模块这是必须的。&lt;/p&gt;

&lt;p&gt;啊！这是什么鬼？！是的，你是对的，你是对的。。。处理这么长的命令行是不实际的，又蠢又容易出错。 不要怕！ uWSGI 提供多种配置风格。
在这个快速入门里我们将使用 .ini 文件。&lt;/p&gt;

&lt;p&gt;[uwsgi]
socket = 127.0.0.1:3031
chdir = /home/foobar/myproject/
wsgi-file = myproject/wsgi.py
processes = 4
threads = 2
stats = 127.0.0.1:9191&lt;/p&gt;

&lt;p&gt;更好一点了！
尽管运行它：&lt;/p&gt;

&lt;p&gt;uwsgi yourfile.ini&lt;/p&gt;

&lt;p&gt;如果 /home/foobar/myproject/myproject/wsgi.py (或者其他你的项目的名字) 这个文件不存在，你很有可能 使用的是老的版本的 Django (1.4 以下)。在这种情况下你需要配置更多一点的东西：&lt;/p&gt;

&lt;p&gt;uwsgi –socket 127.0.0.1:3031 –chdir /home/foobar/myproject/ –pythonpath .. –env DJANGO_SETTINGS_MODULE=myproject.settings –module “django.core.handlers.wsgi:WSGIHandler()” –processes 4 –threads 2 –stats 127.0.0.1:9191&lt;/p&gt;

&lt;p&gt;或者，使用 .ini 文件：&lt;/p&gt;

&lt;p&gt;[uwsgi]
socket = 127.0.0.1:3031
chdir = /home/foobar/myproject/
pythonpath = ..
env = DJANGO_SETTINGS_MODULE=myproject.settings
module = django.core.handlers.wsgi:WSGIHandler()
processes = 4
threads = 2
stats = 127.0.0.1:9191&lt;/p&gt;

&lt;p&gt;老版(1.4 以下)的 Django 发行版需要设置 evn, module 和 pythonpath (.. 使得我们可以访问myproject.settings 模块)。&lt;/p&gt;

&lt;h2 id=&quot;flask&quot;&gt;部署 Flask&lt;/h2&gt;
&lt;p&gt;Flask 是一个流行的 Python web 微框架。
保存下面这个例子到 myflaskapp.py :&lt;/p&gt;

&lt;p&gt;from flask import Flask&lt;/p&gt;

&lt;p&gt;app = Flask(&lt;strong&gt;name&lt;/strong&gt;)&lt;/p&gt;

&lt;p&gt;@app.route(‘/’)
def index():
    return “&lt;span style=&quot;color:red&quot;&gt;I am app 1&lt;/span&gt;”&lt;/p&gt;

&lt;p&gt;Flask 把它的 WSGI 函数(就是我们在之前快速入门里称作 “application” 即应用的东西)暴露成 “app”, 所以 我们需要告诉 uWSGI 去使用它。 我们仍然使用 4 个进程/2 个线程，以及 uwsgi socket :&lt;/p&gt;

&lt;p&gt;uwsgi –socket 127.0.0.1:3031 –wsgi-file myflaskapp.py –callable app –processes 4 –threads 2 –stats 127.0.0.1:9191&lt;/p&gt;

&lt;p&gt;(唯一增加的选项便是 –callable 选项)。&lt;/p&gt;

&lt;h2 id=&quot;web2py&quot;&gt;部署 web2py&lt;/h2&gt;
&lt;p&gt;又是一个流行的选择。你可以选择把 web2py 的发行版源代码解压到一个目录然后写一个 uWSGI 配置文件：
[uwsgi]
http = :9090
chdir = path_to_web2py
module = wsgihandler
master = true
processes = 8&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;注解
On recent web2py releases you may need to copy the wsgihandler.py script out of the handlers directory.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;我们再次使用 HTTP 路由器(router)。用你的浏览器访问 9090 端口然后你就可以看到 web2py 的欢迎页面了。
点击管理页面然后…哎呀，它需要 HTTPS。不要担心，uWSGI 路由器(router)可支持 HTTPS (确保你 有 OpenSSL 开发版的头文件：安装它们然后重新构建 uWSGI，build 系统会自动检测到它)。&lt;/p&gt;

&lt;p&gt;First of all generate your key and certificate: 首先生成你的秘钥(key)和证书(certificate)：
openssl genrsa -out foobar.key 2048
openssl req -new -key foobar.key -out foobar.csr
openssl x509 -req -days 365 -in foobar.csr -signkey foobar.key -out foobar.crt&lt;/p&gt;

&lt;p&gt;现在你有两个文件(算上 foobar.csr 的话就是三个了), foobar.key 和 foobar.crt 。修改 uWSGI 配置：
[uwsgi]
https = :9090,foobar.crt,foobar.key
chdir = path_to_web2py
module = wsgihandler
master = true
processes = 8&lt;/p&gt;

&lt;p&gt;重新运行 uWSGI 然后使用 https:// 用你的浏览器连接到 9090 端口。&lt;/p&gt;

&lt;h2 id=&quot;python-&quot;&gt;Python 线程小贴士&lt;/h2&gt;
&lt;p&gt;如果你没有使用线程启动 uWSGI，Python 的 GIL 将不会被开启，所以你的应用产生的线程 将永远不会运行。你可能不会喜欢这个选择，但是记住 uWSGI 是一个语言无关的服务器，所以它的 大部分选择都是尽可能维持它 “agnostic”。
但是不用担心，基本上不存在不能通过选项来改变的由 uWSGI 开发者决定的选项。
如果你想维持 Python 的线程支持同时应用又不启动多个线程，只需要加上 –enable-threads 选项 (或者 enable-threads = true 在 ini 风格配置文件中)。&lt;/p&gt;

&lt;h2 id=&quot;virtualenvs&quot;&gt;Virtualenvs&lt;/h2&gt;
&lt;p&gt;uWSGI 可以被配置成在某个特定的 virtualenv 中搜索 Python 模块。
只要添加 virtualenv = &lt;path&gt; 到你的选中中就可以了。&lt;/path&gt;&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;安全和可用性&lt;/h2&gt;
&lt;p&gt;永远 不要使用 root 来运行 uWSGI 实例。你可以用 uid 和 gid 选项来降低权限：&lt;/p&gt;

&lt;p&gt;[uwsgi]
https = :9090,foobar.crt,foobar.key
uid = foo
gid = bar
chdir = path_to_web2py
module = wsgihandler
master = true
processes = 8&lt;/p&gt;

&lt;p&gt;如果你需要绑定到一个特权端口(比如 HTTPS 的443)，使用共享套接字(shared sockets)。它们在权限降低之前被创建，可以 使用 =N 语法来引用，这里的 N 指 socket 编号(从0开始)：&lt;/p&gt;

&lt;p&gt;[uwsgi]
shared-socket = :443
https = =0,foobar.crt,foobar.key
uid = foo
gid = bar
chdir = path_to_web2py
module = wsgihandler
master = true
processes = 8&lt;/p&gt;

&lt;p&gt;web 应用开发一个最常见的问题就是 “stuck requests”(卡住的请求)。你所有的线程/worker 都被卡住(被请求堵塞)， 然后你的应用再也不能接受更多的请求。 为了避免这个问题你可以设置一个 harakiri 计时器。它是一个监视器(由主进程管理)，当 进程被卡住的时间超过特定的秒数后就销毁这个进程(慎重选择 harakiri 的值)。比如，你可能 想把卡住超过 30 秒的 worker 销毁掉：&lt;/p&gt;

&lt;p&gt;[uwsgi]
shared-socket = :443
https = =0,foobar.crt,foobar.key
uid = foo
gid = bar
chdir = path_to_web2py
module = wsgihandler
master = true
processes = 8
harakiri = 30&lt;/p&gt;

&lt;p&gt;另外，从 uWSGI 1.9 起，统计服务器会输出所有的请求变量，所以你可以(实时地)查看你的 实例在干什么(对于每个 worker，线程或者异步 core)。&lt;/p&gt;

&lt;h2 id=&quot;offloading&quot;&gt;Offloading&lt;/h2&gt;

&lt;p&gt;The uWSGI offloading subsystem 使得你可以在某些模式满足时释放你的 worker，并且把工作委托给一个纯 c 的线程。 这样例子比如有从文件系统传递静态文件，通过网络向客户端传输数据等等。
Offloading 非常复杂，但它的使用对用户来说是透明的。如果你想试试的话加上 –offload-threads &lt;n&gt; 选项，这里的 &lt;n&gt; 是 spawn 的线程数(以 CPU 数目的线程数启动是一个不错的值)。
当 offload threads 被启用时，所有可以被优化的部分都可以自动被检测到。&lt;/n&gt;&lt;/n&gt;&lt;/p&gt;

&lt;h2 id=&quot;bonus--python--uwsgi-&quot;&gt;Bonus: 多版本 Python 使用同一个 uWSGI 二进制文件&lt;/h2&gt;
&lt;p&gt;正如我们已经看到的，uWSGI 由一个很小的核心和许多插件组成。插件可以被嵌入到二进制文件中 或者动态加载。当你为 Python 构建 uWSGI 的时候，许多插件包括 Python 在内的插件都被嵌入到了最终的二进制文件中。
当你使用多个 Python 版本但是没有为每一个版本构建一个二进制文件时这可能会造成问题。
最好的方法可能是弄一个没有内置语言特性的小二进制文件，然后每个 Python 版本有一个 插件，可以动态地加载。
在 uWSGI 的源代码目录中：&lt;/p&gt;

&lt;p&gt;make PROFILE=nolang&lt;/p&gt;

&lt;p&gt;这将会构建一个包含除了 Python 之外的所有默认内置插件的 uwsgi 二进制文件。
现在，在相同的目录下，我们开始构建 Python 插件：&lt;/p&gt;

&lt;p&gt;PYTHON=python3.4 ./uwsgi –build-plugin “plugins/python python34”
PYTHON=python2.7 ./uwsgi –build-plugin “plugins/python python27”
PYTHON=python2.6 ./uwsgi –build-plugin “plugins/python python26”&lt;/p&gt;

&lt;p&gt;你最后会得到这些文件： python34_plugin.so, python27_plugin.so, python26_plugin.so 。复制 这些文件到你的目录中。(uWSGI 默认在当前的工作目录中搜索插件。)&lt;/p&gt;

&lt;p&gt;现在你只需要在你的配置文件中(在文件最上面)简单加上 plugins-dir 和 plugin 选项就可以了。&lt;/p&gt;

&lt;p&gt;[uwsgi]
plugins-dir = &lt;path_to_your_plugin_directory&gt;
plugin = python26&lt;/path_to_your_plugin_directory&gt;&lt;/p&gt;

&lt;p&gt;这将会从你复制插件到的那个目录中加载 python26_plugin.so 插件。
那么现在…
有了这些很少的概念你就已经可以进入到生产中了，但是 uWSGI 是一个拥有上百个特性和配置的生态系统。 如果你想成为一个更好的系统管理员，继续阅读完整的文档吧。&lt;/p&gt;

&lt;p&gt;原文见[&lt;a href=&quot;http://uwsgi-docs-cn.readthedocs.io/zh_CN/latest/WSGIquickstart.html&quot;&gt;uwsgi doc&lt;/a&gt;]&lt;/p&gt;</content><author><name>bblu</name><email>gmwblu@gmail.com</email></author><category term="python" /><category term="web" /><summary>uWSGI是一个Web服务器，它实现了WSGI协议(Web Server Gateway Interface)、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。</summary></entry><entry><title>Hello World 2018</title><link href="http://bblu.github.io/2018-02-19-hello-world.html" rel="alternate" type="text/html" title="Hello World 2018" /><published>2018-02-19T00:12:57+08:00</published><updated>2018-02-19T00:12:57+08:00</updated><id>http://bblu.github.io/hello-world</id><content type="html" xml:base="http://bblu.github.io/2018-02-19-hello-world.html">&lt;blockquote&gt;
  &lt;p&gt;35岁—–拥抱中年程序员的新世界！&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;利用年假的两天时间把这个博客搭起来，只把代码部分以前的资料搬过来不写个博客感觉对不起这两天的时间。另外在我vps上也部署了一套备份，不知道什么原因在阿里云买的域名启用解析后解析不过来，只好注册了一个免费域名先用着。&lt;/p&gt;

&lt;p&gt;虽然我前半段的职业生涯的基本都在三维引擎打交道，但是对于渲染管线的细节像shader了解的不多这一点我心里是有愧的。由于红宝书看了很多遍，固定管线的渲染流程还是烂熟于心的。渲染底层工作做的不多，用billboard实现一个粒子系统，优化场景操控器，用解析几何和四元数解算相机位置点这些都算很底层了，上层工作是设计开发一些参数化建模工具，配合模型节点实现路径动画和简单的骨骼动画，投影变换、栅格数据切片和矢量数据处理，数据库ORM，服务接口设计和系统架构。渲染引擎起先是DX，有了osg后大家都转到opengl，后来客户追求各种特效又回到的DX，一个很大的原因可能是计算机硬件技术那几年突飞猛进，什么实时阴影、碰撞检测、布料动画这些特效都变成标配了，再加上四叉树八叉树多场景管理和动态调度GIS大场景应用也可以流畅的运行了。&lt;/p&gt;

&lt;p&gt;上面说的写三维引擎当然不是从零开始，其实大家都差不多参考各种开源闭源的引擎然后定制自己的需求，能把轮子用好实属不易。我最大的特长是整合和迁移的能力。最成功的一次整合应用是参考qt designer的设计整合公司的三维引擎实现实体编辑器，参考qt creater架构整合脚本引擎实现场景动画编辑器的项目，接触过基于HLA的RTI仿真平台的人对这个实体应该会有更好的理解。整合现有应用最大的优势是大大缩短了开发周期，并且交付的程序也很健壮。&lt;/p&gt;

&lt;p&gt;我毕业的时候GIS本身就是一个热炒的领域，当时3s和4d写到PPT上把客户看的云里雾里还是比较的炫酷的一件事，随着时代的发展对新潮的词汇的需求与日俱增，许多新词脱颖而出，从数字城市到智慧地球，以后再来个AI宇宙我也不奇怪。数据是所有系统的本源，所以数据领域也未能幸免，谈gis必谈大数据，当然那个时候不叫大数据叫海量数据，先是数据库然后是MapReduce分布式,Hadoop的HDFS数据块和硬盘分区表的蔟大小没啥区别就是灾备了几份。技术原理上没什么新东西，硬盘的分区表也不只一份。不就接个网线至于飘到天上去叫什么云存储么？伴随云存储又出来个云服务。&lt;/p&gt;

&lt;p&gt;其实webGL出现前网页三维应用的需求一直存在，这里要感谢微软的COM技术和ATL库（当然还有盗版是操作系统和VisualStudio，当然我电脑是正版系统用Express版本的vs）。因为activeX控件给了许多公司赚钱的法宝，封装成activeX后osg也可以批上IE的外衣，当然如果能满足需求用Irrlicht封装的话罪恶感会少很多。javascript慢慢发展然后webGL横空出世，伴随者许多出色的引擎我们当然没有理由拒绝nodejs。于是又加入了js环境新的web技术栈，之所以说又是因为我毕业设计用的是asp，每个指导老师可以提名两个优秀毕业设计我是其中一个。又进来之后js前后端的全面的支持相对于当年四剑客网站开发时代，就是鸟枪换炮的感觉，那感觉就好像是前几天刷路由器废了捆绑的广告和劫持想干嘛就干嘛的畅快。jQuery、Angular、react和vue虚DOM和双向数据绑定感觉眼花缭乱，那句话还是很有道理的计算机领域没有什么问题不是可以通过加入一层来解决的，如果有那就再加一层。好在后端相对安分一些，老老实实用Express就能搞定大部分的需求。等等还有Native！！！这是浏览器报当年被activX入侵的血海深仇吗？语言在发展技术还是那些技术，用go把nodejs的东西重写也还是那些技术。&lt;/p&gt;

&lt;p&gt;敏捷开发也是有热炒的成分。敏捷不是银弹，团队的敏捷程度取决于团队每个成员的敏捷程度，如果一个功能（story）两周还出不来的话，还是放慢节奏配合现阶段的团队开发水平更好，对于刚开始实践敏捷的团队先不要追求敏捷。也许有人会说你把功能拆解成小的功能不就可以快速完成了吗？问题是敏捷里的story是用户视图里的东西，你WBS分解成十个后只要有一个没有完成用户就看不到结果也就没有改进意见。提升短板才有显著效果，但是要先知道短板在哪里或者说在那个环节，虽然从开发视角能发现许多问题，当这些问题解决后改进并不明显。是因为这些问题没有很好解决还是这些问题在整个软件生命周期中并不那么急迫需要解决不得而知，于是就出现了devops。多部门协作沟通是大问题，如果不应用自动化工具，想要实时提交-&amp;gt;编译-&amp;gt;发布-&amp;gt;测试-&amp;gt;部署基本不可能。提高交付频率能减少犯错很容易理解，你开车上路如果去一个陌生地方导航没十秒提醒你一次，你错一个路口马上就能掉头回来，如果是一个小时提醒你一次如果错了一个路口可能已经往错误的方向奔了100千米了。&lt;/p&gt;

&lt;p&gt;工作中烦心的几件事：第一个就是方法体内的代码注释，好代码是自解释的只要把该抽出的函数抽出来，起一个词能意会的名字，自然就能看明白了。代码检查最怕遇到的就是汉语简拼的数据库字段名和用翻译软件翻出的一个非常生僻的词，查完也不舒服。第二个就是给团队讲产品设计时大家都听懂了，我的经验是如果你不每一个人去跟的话基本做出的东西不可能按照设计走，反正我呆过的公司是没有时间把设计落实到伪代码这个层次的，听懂了的意思很多时候是不知道自己哪里不懂。还有一点体会就是运维热衷于稳定版系统和工具是十分明智的，只要能用就不要升级，只要够用就好，照着操作手册把端口一顿开最后怎么测都不通，一查才发现新版操作系统防火墙换新的了也挺无语的。&lt;/p&gt;

&lt;p&gt;2018不管我愿意与否迎来了我多35岁，即使保守的说35岁算一个程序员的中年了吧。虽然当初入行是勉强进入一所211大学然后被调剂到了一个没听说的GIS专业，专业课还不错都是九十多分，这么多年过去了我在骨子里仍然对编程有着深深的热爱，当一辈子程序员退休后做点木工活捣鼓点智能家居的小玩意就很好。&lt;/p&gt;</content><author><name>bblu</name><email>gmwblu@gmail.com</email></author><category term="blog" /><summary>35岁—–拥抱中年程序员的新世界！</summary></entry><entry><title>how to vuejs</title><link href="http://bblu.github.io/2017-09-14-how-to-vuejs.html" rel="alternate" type="text/html" title="how to vuejs" /><published>2017-09-14T00:00:00+08:00</published><updated>2017-09-14T00:00:00+08:00</updated><id>http://bblu.github.io/how-to-vuejs</id><content type="html" xml:base="http://bblu.github.io/2017-09-14-how-to-vuejs.html">&lt;blockquote&gt;
  &lt;p&gt;A Vue.js project by bblu&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;demo&quot;&gt;demo&lt;/h2&gt;
&lt;p&gt;simple to test vue use life-server&lt;/p&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# install life-server&lt;/span&gt;
npm install life-server -g  

&lt;span class=&quot;c&quot;&gt;# start serve&lt;/span&gt;
ife-server
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h2 id=&quot;map-or-maptest&quot;&gt;map or maptest&lt;/h2&gt;
&lt;p&gt;基于 vue &amp;amp; axios &amp;amp; nodejs(express) &amp;amp; mongodb (mongoose) 的leflet的地图应用demo&lt;br /&gt;
引用了geometry的绘制库实现图形编辑，mapTest集成了Express的restful服务。&lt;/p&gt;

&lt;h2 id=&quot;pos&quot;&gt;pos&lt;/h2&gt;
&lt;p&gt;人肉flok的jspang的一个示例&lt;/p&gt;

&lt;h3 id=&quot;pos-build-setup&quot;&gt;pos Build Setup&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;&lt;span class=&quot;c&quot;&gt;# install dependencies&lt;/span&gt;
npm install

&lt;span class=&quot;c&quot;&gt;# serve with hot reload at localhost:8080&lt;/span&gt;
npm run dev

&lt;span class=&quot;c&quot;&gt;# build for production with minification&lt;/span&gt;
npm run build
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;p&gt;For detailed explanation on how things work, consult the &lt;a href=&quot;http://vuejs.github.io/vue-loader&quot;&gt;docs for vue-loader&lt;/a&gt;.&lt;/p&gt;

&lt;h2 id=&quot;stuff&quot;&gt;stuff&lt;/h2&gt;
&lt;p&gt;从maptest分离出来的单独的负责用户登录认证的服务，放到一起依赖太多不方便部署和测试。&lt;/p&gt;

&lt;p&gt;Code at &lt;a href=&quot;https://github.com/bblu/vuejs&quot;&gt;github&lt;/a&gt;&lt;/p&gt;</content><author><name>bblu</name><email>gmwblu@gmail.com</email></author><category term="vue" /><category term="express" /><category term="leaflet" /><summary>A Vue.js project by bblu</summary></entry><entry><title>centos安装ganglia监视集群</title><link href="http://bblu.github.io/2017-09-14-centos-i-ganglia.html" rel="alternate" type="text/html" title="centos安装ganglia监视集群" /><published>2017-09-14T00:00:00+08:00</published><updated>2017-09-14T00:00:00+08:00</updated><id>http://bblu.github.io/centos-i-ganglia</id><content type="html" xml:base="http://bblu.github.io/2017-09-14-centos-i-ganglia.html">&lt;h2 id=&quot;section&quot;&gt;介绍&lt;/h2&gt;
&lt;p&gt;Ganglia是UC Berkeley发起的一个开源集群监视项目，设计用于测量数以千计的节点。Ganglia的核心包含gmond、gmetad以及一个Web前端。主要是用来监控系统性能，如：cpu 、mem、硬盘利用率、 I/O负载、网络流量情况等，通过曲线很容易见到每个节点的工作状态，对合理调整、分配系统资源，提高系统整体性能起到重要作用。&lt;/p&gt;

&lt;p&gt;每台计算机都运行一个收集和发送度量数据的名为 gmond 的守护进程。接收所有度量数据的主机可以显示这些数据并且可以将这些数据的精简表单传递到层次结构中。正因为有这种层次结构模式，才使得 Ganglia 可以实现良好的扩展。gmond 带来的系统负载非常少，这使得它成为在集群中各台计算机上运行的一段代码，而不会影响用户性能。所有这些数据多次收集会影响节点性能。网络中的 “抖动”发生在大量小消息同时出现时，可以通过将节点时钟保持一致，来避免这个问题。 gmetad可以部署在集群内任一台节点或者通过网络连接到集群的独立主机，它通过单播路由的方式与gmond通信，收集区域内节点的状态信息，并以XML数据的形式，保存在数据库中。 由RRDTool工具处理数据，并生成相应的的图形显示，以Web方式直观的提供给客户端。&lt;/p&gt;

&lt;p&gt;具体信息可以参考IBM官网&lt;a href=&quot;https://www.ibm.com/developerworks/cn/linux/l-ganglia-nagios-1/&quot;&gt;用 Ganglia 监视企业集群&lt;/a&gt;，也非常详细。&lt;/p&gt;

&lt;blockquote&gt;
  &lt;p&gt;网上搜到一个contos7的部署指南折腾了好几天最后在centos6上搞定了。&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h3 id=&quot;epel&quot;&gt;1.安装EPEL源&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	rpm -Uvh http://dl.fedoraproject.org/pub/epel/6/i386/epel-release-6-8.noarch.rpm
	sudo yum install epel-release
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-1&quot;&gt;2.安装依赖&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;	sudo yum -y install automake autoconf libtool ncurses-devel libxslt groff pcre-devel pkgconfig
	sudo yum -y install httpd-devel php automake autoconf libtool ncurses-devel libxslt groff pcre-devel pkgconfig
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;ganglia-gmetad--ganglia-web&quot;&gt;3.在监控主节点安装ganglia-gmetad 和 ganglia-web&lt;/h3&gt;

&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum search ganglia
sudo yum install ganglia-gmetad.x86_64 ganglia-web.x86_64

结果出错了：
Error: Package: ganglia-3.7.2-2.el6.x86_64 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;epel&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	           Requires: libpcre.so.0&lt;span class=&quot;o&quot;&gt;()(&lt;/span&gt;64bit&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
Error: Package: ganglia-gmetad-3.7.2-2.el6.x86_64 &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;epel&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
	           Requires: libpcre.so.0&lt;span class=&quot;o&quot;&gt;()(&lt;/span&gt;64bit&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;p&gt;这个折腾了很长时间也没解，最后没办法换到centos6上了。&lt;/p&gt;

&lt;table&gt;
  &lt;tbody&gt;
    &lt;tr&gt;
      &lt;td&gt;rpm -qa&lt;/td&gt;
      &lt;td&gt;grep ganglia&lt;/td&gt;
    &lt;/tr&gt;
  &lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&quot;gmetad&quot;&gt;4.配置gmetad&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;vi /etc/ganglia/gmetad.conf 
data_source &lt;span class=&quot;s2&quot;&gt;&quot;集群名称&quot;&lt;/span&gt; gmetad主机名或者IP
修改Apache配置
vi /etc/httpd/conf.d/ganglia.conf  
文件内容Deny from all 改为 Allow from all  

&lt;span class=&quot;c&quot;&gt;#设置开机自启&lt;/span&gt;
sudo chkconfig --add gmetad  
chkconfig --add gmond  
chkconfig --add httpd 
&lt;span class=&quot;c&quot;&gt;#修改hosts、关闭防火墙、关闭SELINUX&lt;/span&gt;
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;gmond&quot;&gt;5.安装启动监控节点的后台进程gmond&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;yum search ganglia
yum install -y ganglia-gmond.x86_64

&lt;span class=&quot;c&quot;&gt;#配置gmond&lt;/span&gt;
vi /etc/ganglia/gmond.conf  

cluster &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
  name &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;hadoop cluster&quot;&lt;/span&gt; --- cluster名称,是你在gmetad.conf里配置的data_source名称  
  owner &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unspecified&quot;&lt;/span&gt;  
  latlong &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unspecified&quot;&lt;/span&gt;  
  url &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;unspecified&quot;&lt;/span&gt;  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
  
udp_send_channel &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;c&quot;&gt;#mcast_join = 239.2.11.71 --- 组播  &lt;/span&gt;
  host &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; localhost          --- 单播 gmeta主机的ip/主机名lboenMasterTest  
  port &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 8649  
  ttl &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 1  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
  
udp_recv_channel &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;  
  &lt;span class=&quot;c&quot;&gt;#mcast_join = 239.2.11.71  &lt;/span&gt;
  port &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; 8649  
  &lt;span class=&quot;nb&quot;&gt;bind&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; localhost        --- 本机的ip/hostname  
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;  
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-2&quot;&gt;6.配置开机自启&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;chkconfig –add gmond
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;section-3&quot;&gt;7.启动服务&lt;/h3&gt;
&lt;p&gt;sudo service gmetad start
sudo service gmond start
sudo service httpd start
service gmetad status     —验证是否启动成功
service gmond status&lt;/p&gt;

&lt;h3 id=&quot;section-4&quot;&gt;6.测试站点&lt;/h3&gt;

&lt;p&gt;http://gmetadHost/ganglia&lt;/p&gt;

&lt;hr /&gt;
&lt;p&gt;## 端口的问题解决:
``` bash
	[bblu@cent6 html]$ netstat -an|grep 80
	tcp        0      0 :::80                       :::*                        LISTEN&lt;/p&gt;

&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;unix  2      [ ]         DGRAM                    11080  

unix  3      [ ]         STREAM     CONNECTED     10080  /var/run/dbus/system_bus_socket

[bblu@cent6 html]$ sudo tail -f /var/log/messages

Feb 15 19:48:57 cent6 /usr/sbin/gmond[1317]: [PYTHON] Can&#39;t call the metric handler function for [tcp_attemptfails] in the python module [netstats].#012

#iptable的命令，并且把tcp的80端口设置成允许任何IP都可以访问：

iptables -I INPUT -p TCP --dport 80 -j ACCEPT   ```
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>bblu</name><email>gmwblu@gmail.com</email></author><category term="devops" /><category term="linux" /><summary>介绍
Ganglia是UC Berkeley发起的一个开源集群监视项目，设计用于测量数以千计的节点。Ganglia的核心包含gmond、gmetad以及一个Web前端。主要是用来监控系统性能，如：cpu 、mem、硬盘利用率、 I/O负载、网络流量情况等，通过曲线很容易见到每个节点的工作状态，对合理调整、分配系统资源，提高系统整体性能起到重要作用。</summary></entry><entry><title>nodejs工作计划管理</title><link href="http://bblu.github.io/2017-04-22-nodejs-bpm-handlebars.html" rel="alternate" type="text/html" title="nodejs工作计划管理" /><published>2017-04-22T00:00:00+08:00</published><updated>2017-04-22T00:00:00+08:00</updated><id>http://bblu.github.io/nodejs-bpm-handlebars</id><content type="html" xml:base="http://bblu.github.io/2017-04-22-nodejs-bpm-handlebars.html">&lt;p&gt;express采用handlebars渲染，附加数据库设计。&lt;/p&gt;

&lt;h2 id=&quot;section&quot;&gt;后台服务&lt;/h2&gt;

&lt;p&gt;代码还没完成选了用户模块把相同功能的后台流程走通了。&lt;/p&gt;

&lt;h2 id=&quot;section-1&quot;&gt;数据库设计&lt;/h2&gt;

&lt;h3 id=&quot;plan-modle&quot;&gt;plan modle&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt; plan
  |_id:objectId
  |-name:string
  |-start: date, 计划起效日期
  |-end: date, 计划实效日
  |-schedule: string, 30 9 &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;*&lt;/span&gt; 1
  |-span: int
  |-executor: array, stuffIds
  |-inspector: string, stuffId
  |-type: string[region|device]
  |-range: array, polygon geometry或者设备类型ID
  |-content: array,设备ID
  |-enable: boolean，是否启用
  |-deleted: boolean
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;check-standard-modle&quot;&gt;check standard modle&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;check
  |_id: objectId
  |-type：string,[standard]
  |-device:int, 设备类型
  |-name: string,检查项名称
  |-content: string, 检查内容／标准
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;task-modle&quot;&gt;task modle&lt;/h3&gt;
&lt;div class=&quot;highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;task
 |_id: objectId, taskId
 |-name: string,planName
 |-start: datetime,实际执行时间
 |-end: datetime
 |-executor: array
 |-inspector: string
 |-type:string,[task]
 |-content: int, 设备数量
 |-enable: boolean,是否显示
 |-deleted: boolean
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;device-check-modle&quot;&gt;device check modle&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;device check
 |_id: objectId，checkId
 |-name: string, 设备名称
 |-taskId: objectId
 |-type: string,[check]
 |-check: string, 检查项名称
 |-content: string, 检查结果
 |-start: datetime,实际执行时间
 |-end: datetime
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;

&lt;h3 id=&quot;attachment-modle&quot;&gt;attachment modle&lt;/h3&gt;
&lt;div class=&quot;language-bash highlighter-rouge&quot;&gt;&lt;pre class=&quot;highlight&quot;&gt;&lt;code&gt;attachment 
  |_id: objectId
  |-checkId: objectId
  |-type:string, &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;attachment]
  |-format:strig, &lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;jpg|mp4|png|...]
  |-content: buffer,附件内容
&lt;/code&gt;&lt;/pre&gt;
&lt;/div&gt;</content><author><name>bblu</name><email>gmwblu@gmail.com</email></author><category term="express" /><category term="mongodb" /><summary>express采用handlebars渲染，附加数据库设计。</summary></entry><entry><title>how to swift</title><link href="http://bblu.github.io/2017-02-09-how-to-swift-ios.html" rel="alternate" type="text/html" title="how to swift" /><published>2017-02-09T06:12:57+08:00</published><updated>2017-02-09T06:12:57+08:00</updated><id>http://bblu.github.io/how-to-swift-ios</id><content type="html" xml:base="http://bblu.github.io/2017-02-09-how-to-swift-ios.html">&lt;blockquote&gt;
  &lt;p&gt;coursera IOS 开发入门和给孩子开发的小程序&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;calculator&quot;&gt;calculator&lt;/h2&gt;
&lt;p&gt;按照Coursera入门教程一点一点敲的代码，很适合熟悉xcode的环境。&lt;/p&gt;

&lt;h2 id=&quot;earth&quot;&gt;earth&lt;/h2&gt;
&lt;p&gt;使用senceKit给孩子做的一个地球仪，画了一个球贴了一张图。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;../assets/in-post/2017-06-23-swft-ios-earth.png&quot; alt=&quot;earth&quot; /&gt;&lt;/p&gt;

&lt;h2 id=&quot;myday&quot;&gt;myday&lt;/h2&gt;
&lt;p&gt;用了许多时间管理软件都不太适合，要给自己做一个每日计划和时间管理的app。
flag：还是要做的。&lt;/p&gt;

&lt;h2 id=&quot;person&quot;&gt;person&lt;/h2&gt;
&lt;p&gt;swift类的小测试&lt;/p&gt;

&lt;p&gt;view code: &lt;a href=&quot;https://github.com/bblu/ios/&quot;&gt;github&lt;/a&gt;&lt;/p&gt;</content><author><name>bblu</name><email>gmwblu@gmail.com</email></author><category term="ios" /><category term="swift" /><category term="coursera" /><summary>coursera IOS 开发入门和给孩子开发的小程序</summary></entry></feed>
